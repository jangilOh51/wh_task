# 테스트 아키텍처 설명 문서

## 1. 테스트 케이스 목록

이 프로젝트의 테스트 케이스는 주요 API 기능인 '메뉴 선택'과 '주문 생성'에 중점을 두고 설계되었습니다. 각 API에 대해 성공 케이스(Happy Path)와 다양한 예외 상황을 고려한 실패 케이스(Negative Path)를 포괄적으로 구성했습니다.

### 1.1. 메뉴 선택 API (`test_menu.py`)

메뉴 선택 API는 주문 프로세스의 첫 단계로, 사용자가 메뉴를 선택하고 예약을 생성하는 기능입니다. 파라미터 유효성 검증과 재고 상태 확인이 핵심입니다.

| No. | 테스트 케이스 | 테스트 목적 | 설계 의도 |
|---|---|---|---|
| 1 | 메뉴 선택 성공 | 정상적인 메뉴 선택 및 예약 생성 기능 확인 | 가장 기본적인 성공 시나리오를 검증합니다. |
| 2 | 재료 부족으로 실패 | 재고가 부족할 때 메뉴 선택이 거부되는지 확인 | 재고 관리 시스템과의 연동 및 예외 처리 로직을 검증합니다. |
| 3 | 유효하지 않은 인증으로 실패 | 인증 토큰이 없거나 유효하지 않을 때의 접근 제어 확인 | API의 보안 및 인증 처리 로직을 검증합니다. |
| 4 | 유효하지 않은 메뉴 ID | 존재하지 않는 메뉴를 선택했을 때의 예외 처리 확인 | 데이터 유효성 검증 로직을 테스트합니다. |
| 5 | 수량 0 또는 음수로 실패 | 비정상적인 수량 값에 대한 방어 로직 확인 | 경계값 및 유효하지 않은 입력값에 대한 서버의 처리 능력을 검증합니다. |
| 6 | 최대 주문 수량 초과 | 시스템이 처리할 수 있는 최대 수량을 초과했을 때의 처리 확인 | 시스템의 한계치를 테스트하고 오버플로우 등의 문제를 방지하는지 확인합니다. |
| 7 | 유효하지 않은 상점/회원 ID | 존재하지 않는 상점 또는 회원 정보로 요청 시의 예외 처리 확인 | 데이터 무결성 및 유효성 검증 로직을 테스트합니다. |
| 8 | 필수 파라미터 누락 | 요청 시 필수 값이 누락되었을 때의 처리 확인 | 각 필수 파라미터에 대한 서버의 유효성 검증 로직을 개별적으로 테스트합니다. |

### 1.2. 주문 생성 API (`test_order_create.py`)

주문 생성 API는 메뉴 선택 단계에서 받은 예약 ID를 사용하여 최종적으로 주문을 확정하는 기능입니다. 예약의 유효성(시간, 상태 등)을 검증하는 것이 중요합니다.

| No. | 테스트 케이스 | 테스트 목적 | 설계 의도 |
|---|---|---|---|
| 1 | 주문 생성 성공 | 정상적인 주문 생성 기능 확인 | 메뉴 선택부터 주문 생성까지 이어지는 전체 성공 시나리오를 검증합니다. |
| 2 | 예약과 다른 회원 정보로 실패 | 예약 시의 회원과 주문 시의 회원이 다를 경우의 예외 처리 확인 | 주문의 소유권을 확인하는 보안 로직을 검증합니다. |
| 3 | 유효하지 않은 예약 ID | 존재하지 않거나 잘못된 예약 ID 사용 시의 예외 처리 확인 | 데이터 유효성 및 에러 핸들링을 테스트합니다. |
| 4 | 예약 후 5분 초과로 실패 | 예약 유효 시간이 만료되었을 때 주문이 거부되는지 확인 | 예약 시스템의 시간 기반 만료 정책을 검증합니다. |
| 5 | 예약 후 재료 소진으로 실패 | 예약 시점에는 재고가 있었으나 주문 시점에 소진된 경우의 처리 확인 | 실시간 재고 변동에 따른 동시성 이슈 및 예외 처리 로직을 검증합니다. |
| 6 | 동일한 예약 건으로 중복 주문 | 이미 처리된 예약 건으로 다시 주문을 시도할 때의 처리 확인 | 중복 요청을 방지하는 멱등성 관련 로직을 검증합니다. |
| 7 | 필수 파라미터 누락 | 예약 ID 또는 회원 번호가 누락되었을 때의 처리 확인 | 각 필수 파라미터에 대한 서버의 유효성 검증 로직을 테스트합니다. |

---

## 2. 테스트 아키텍처

본 테스트 프레임워크는 **계층화된 설계(Layered Architecture)**를 채택하여 각 부분의 역할을 명확히 분리하고, 유지보수성과 확장성을 높이는 데 중점을 두었습니다.

### 2.1. 아키텍처 시각화 (Mermaid)

```mermaid
graph TD
    A[테스트 케이스 (pytest)] --> B{서비스 레이어 (OrderService)};
    B --> C(API 클라이언트);
    C --> D{데이터 모델 (DTO)};
    C --> E[Mock 서버 응답];
    F[테스트 데이터 (settings.py)] --> D;
    F --> A;

    subgraph "Test Layer"
        A
    end

    subgraph "Business Logic Layer"
        B
    end

    subgraph "API Abstraction Layer"
        C
        D
    end

    subgraph "Test Infrastructure"
        E
        F
    end
```

### 2.2. 주요 구성 요소 설명

1.  **테스트 케이스 (`/tests/scenario`)**
    -   `pytest` 프레임워크를 사용하여 테스트 시나리오를 정의하는 최상위 계층입니다.
    -   `@allure` 데코레이터를 사용하여 테스트의 목적과 종류를 명확히 하고, 상세한 리포트를 생성합니다.
    -   실제 테스트 로직보다는 **서비스 레이어**를 호출하여 시나리오를 실행하는 데 집중합니다.
    -   **왜 이렇게 설계했는가?**: 테스트의 가독성을 높이고, 비즈니스 로직의 변경이 테스트 코드에 미치는 영향을 최소화하기 위함입니다. 시나리오의 흐름을 쉽게 파악할 수 있습니다.

2.  **서비스 레이어 (`/service`)**
    -   `OrderService`와 같이, 여러 API 호출을 조합하여 하나의 완성된 비즈니스 시나리오(예: 메뉴 선택 후 주문)를 구성합니다.
    -   테스트 케이스와 API 클라이언트 사이의 중간 다리 역할을 수행합니다.
    -   **왜 이렇게 설계했는가?**: 복잡한 사용자 시나리오를 테스트할 때, 테스트 케이스가 지나치게 비대해지는 것을 방지합니다. 시나리오 자체의 로직을 재사용할 수 있어 효율적입니다.

3.  **API 클라이언트 (`/api`)**
    -   `MenuSelectApi`, `OrderCreateApi`처럼 각 API 엔드포인트와의 통신을 책임지는 클래스를 정의합니다.
    -   HTTP 요청/응답 처리, 헤더 설정 등 저수준(low-level)의 API 통신 로직을 캡슐화합니다.
    -   **왜 이렇게 설계했는가?**: UI 테스트의 '페이지 객체 모델(Page Object Model)'과 유사한 패턴입니다. API 명세가 변경되더라도 이 계층의 코드만 수정하면 되므로 유지보수가 용이합니다.

4.  **데이터 모델 (DTO, `/model`)**
    -   API 요청 및 응답 데이터의 구조를 정의하는 데이터 전송 객체(Data Transfer Objects)입니다.
    -   `MenuSelectReqDto`, `OrderCreateAssertDto` 등이 여기에 해당합니다.
    -   **왜 이렇게 설계했는가?**: 매직 스트링이나 딕셔너리를 직접 사용하는 대신, 명확한 타입과 필드를 가진 객체를 사용함으로써 코드의 안정성과 가독성을 높입니다.

5.  **Mock 응답 (`/model/mock_res`)**
    -   실제 API 서버 없이 테스트를 진행하기 위해, 다양한 성공/실패 시나리오에 대한 Mock API 응답을 클래스로 정의합니다.
    -   `pytest-mock` 라이브러리를 통해 `requests` 라이브러리의 동작을 가로채고, 미리 정의된 Mock 응답을 반환하도록 합니다.
    -   **왜 이렇게 설계했는가?**: 외부 API 서버의 상태와 관계없이 독립적이고 안정적인 테스트 환경을 구축할 수 있습니다. 다양한 예외 상황을 손쉽게 시뮬레이션할 수 있습니다.

6.  **테스트 데이터 및 설정 (`/codes`)**
    -   `MenuId`, `ShopId` 등 테스트에 사용되는 고정 데이터나 상수 값을 Enum 또는 클래스 변수로 관리합니다.
    -   **왜 이렇게 설계했는가?**: 테스트 데이터가 코드 전반에 흩어져 있는 것을 방지하고, 중앙에서 일관되게 관리하여 변경을 용이하게 합니다.
